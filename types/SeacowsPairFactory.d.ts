/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */

import {
  ethers,
  EventFilter,
  Signer,
  BigNumber,
  BigNumberish,
  PopulatedTransaction,
  BaseContract,
  ContractTransaction,
  Overrides,
  PayableOverrides,
  CallOverrides,
} from "ethers";
import { BytesLike } from "@ethersproject/bytes";
import { Listener, Provider } from "@ethersproject/providers";
import { FunctionFragment, EventFragment, Result } from "@ethersproject/abi";
import type { TypedEventFilter, TypedEvent, TypedListener } from "./common";

interface SeacowsPairFactoryInterface extends ethers.utils.Interface {
  functions: {
    "addLiquidityERC20(address,uint256[],uint256)": FunctionFragment;
    "addLiquidityETH(address,uint256[])": FunctionFragment;
    "bondingCurveAllowed(address)": FunctionFragment;
    "callAllowed(address)": FunctionFragment;
    "chainlinkAggregator()": FunctionFragment;
    "changePriceOracleRegistry(address)": FunctionFragment;
    "changeProtocolFeeMultiplier(uint256)": FunctionFragment;
    "changeProtocolFeeRecipient(address)": FunctionFragment;
    "createPairERC20((address,address,address,address,uint8,uint128,uint96,uint128,uint256[],uint256))": FunctionFragment;
    "createPairERC20WithPriceOracle((address,address,address,address,uint8,uint128,uint96,uint256[],uint256))": FunctionFragment;
    "createPairETH(address,address,address,uint8,uint128,uint96,uint128,uint256[])": FunctionFragment;
    "createPairETHWithPriceOracle(address,address,address,uint8,uint128,uint96,uint256[])": FunctionFragment;
    "depositERC20(address,address,uint256)": FunctionFragment;
    "depositNFTs(address,uint256[],address)": FunctionFragment;
    "enumerableERC20Template()": FunctionFragment;
    "enumerableETHTemplate()": FunctionFragment;
    "initializePairERC20FromOracle(address,address,address,address,uint128,uint96,uint128,uint256[],uint256)": FunctionFragment;
    "initializePairETHFromOracle(address,address,address,uint128,uint96,uint128,uint256[])": FunctionFragment;
    "isPair(address,uint8)": FunctionFragment;
    "missingEnumerableERC20Template()": FunctionFragment;
    "missingEnumerableETHTemplate()": FunctionFragment;
    "owner()": FunctionFragment;
    "priceOracleRegistry()": FunctionFragment;
    "protocolFeeMultiplier()": FunctionFragment;
    "protocolFeeRecipient()": FunctionFragment;
    "removeLiquidityERC20(address,uint256,uint256[])": FunctionFragment;
    "removeLiquidityETH(address,uint256,uint256[])": FunctionFragment;
    "renounceOwnership()": FunctionFragment;
    "routerStatus(address)": FunctionFragment;
    "setBondingCurveAllowed(address,bool)": FunctionFragment;
    "setCallAllowed(address,bool)": FunctionFragment;
    "setRouterAllowed(address,bool)": FunctionFragment;
    "transferOwnership(address)": FunctionFragment;
    "uniswapPriceOracle()": FunctionFragment;
    "withdrawERC20ProtocolFees(address,uint256)": FunctionFragment;
    "withdrawETHProtocolFees()": FunctionFragment;
  };

  encodeFunctionData(
    functionFragment: "addLiquidityERC20",
    values: [string, BigNumberish[], BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "addLiquidityETH",
    values: [string, BigNumberish[]]
  ): string;
  encodeFunctionData(
    functionFragment: "bondingCurveAllowed",
    values: [string]
  ): string;
  encodeFunctionData(functionFragment: "callAllowed", values: [string]): string;
  encodeFunctionData(
    functionFragment: "chainlinkAggregator",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "changePriceOracleRegistry",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "changeProtocolFeeMultiplier",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "changeProtocolFeeRecipient",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "createPairERC20",
    values: [
      {
        token: string;
        nft: string;
        bondingCurve: string;
        assetRecipient: string;
        poolType: BigNumberish;
        delta: BigNumberish;
        fee: BigNumberish;
        spotPrice: BigNumberish;
        initialNFTIDs: BigNumberish[];
        initialTokenBalance: BigNumberish;
      }
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "createPairERC20WithPriceOracle",
    values: [
      {
        token: string;
        nft: string;
        bondingCurve: string;
        assetRecipient: string;
        poolType: BigNumberish;
        delta: BigNumberish;
        fee: BigNumberish;
        initialNFTIDs: BigNumberish[];
        initialTokenBalance: BigNumberish;
      }
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "createPairETH",
    values: [
      string,
      string,
      string,
      BigNumberish,
      BigNumberish,
      BigNumberish,
      BigNumberish,
      BigNumberish[]
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "createPairETHWithPriceOracle",
    values: [
      string,
      string,
      string,
      BigNumberish,
      BigNumberish,
      BigNumberish,
      BigNumberish[]
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "depositERC20",
    values: [string, string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "depositNFTs",
    values: [string, BigNumberish[], string]
  ): string;
  encodeFunctionData(
    functionFragment: "enumerableERC20Template",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "enumerableETHTemplate",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "initializePairERC20FromOracle",
    values: [
      string,
      string,
      string,
      string,
      BigNumberish,
      BigNumberish,
      BigNumberish,
      BigNumberish[],
      BigNumberish
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "initializePairETHFromOracle",
    values: [
      string,
      string,
      string,
      BigNumberish,
      BigNumberish,
      BigNumberish,
      BigNumberish[]
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "isPair",
    values: [string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "missingEnumerableERC20Template",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "missingEnumerableETHTemplate",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "owner", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "priceOracleRegistry",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "protocolFeeMultiplier",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "protocolFeeRecipient",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "removeLiquidityERC20",
    values: [string, BigNumberish, BigNumberish[]]
  ): string;
  encodeFunctionData(
    functionFragment: "removeLiquidityETH",
    values: [string, BigNumberish, BigNumberish[]]
  ): string;
  encodeFunctionData(
    functionFragment: "renounceOwnership",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "routerStatus",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "setBondingCurveAllowed",
    values: [string, boolean]
  ): string;
  encodeFunctionData(
    functionFragment: "setCallAllowed",
    values: [string, boolean]
  ): string;
  encodeFunctionData(
    functionFragment: "setRouterAllowed",
    values: [string, boolean]
  ): string;
  encodeFunctionData(
    functionFragment: "transferOwnership",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "uniswapPriceOracle",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "withdrawERC20ProtocolFees",
    values: [string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "withdrawETHProtocolFees",
    values?: undefined
  ): string;

  decodeFunctionResult(
    functionFragment: "addLiquidityERC20",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "addLiquidityETH",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "bondingCurveAllowed",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "callAllowed",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "chainlinkAggregator",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "changePriceOracleRegistry",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "changeProtocolFeeMultiplier",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "changeProtocolFeeRecipient",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "createPairERC20",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "createPairERC20WithPriceOracle",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "createPairETH",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "createPairETHWithPriceOracle",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "depositERC20",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "depositNFTs",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "enumerableERC20Template",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "enumerableETHTemplate",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "initializePairERC20FromOracle",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "initializePairETHFromOracle",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "isPair", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "missingEnumerableERC20Template",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "missingEnumerableETHTemplate",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "owner", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "priceOracleRegistry",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "protocolFeeMultiplier",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "protocolFeeRecipient",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "removeLiquidityERC20",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "removeLiquidityETH",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "renounceOwnership",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "routerStatus",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setBondingCurveAllowed",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setCallAllowed",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setRouterAllowed",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "transferOwnership",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "uniswapPriceOracle",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "withdrawERC20ProtocolFees",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "withdrawETHProtocolFees",
    data: BytesLike
  ): Result;

  events: {
    "BondingCurveStatusUpdate(address,bool)": EventFragment;
    "CallTargetStatusUpdate(address,bool)": EventFragment;
    "NFTDeposit(address)": EventFragment;
    "NewPair(address)": EventFragment;
    "OwnershipTransferred(address,address)": EventFragment;
    "PriceOracleRegistryUpdate(address)": EventFragment;
    "ProtocolFeeMultiplierUpdate(uint256)": EventFragment;
    "ProtocolFeeRecipientUpdate(address)": EventFragment;
    "RouterStatusUpdate(address,bool)": EventFragment;
    "TokenDeposit(address)": EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: "BondingCurveStatusUpdate"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "CallTargetStatusUpdate"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "NFTDeposit"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "NewPair"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "OwnershipTransferred"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "PriceOracleRegistryUpdate"): EventFragment;
  getEvent(
    nameOrSignatureOrTopic: "ProtocolFeeMultiplierUpdate"
  ): EventFragment;
  getEvent(nameOrSignatureOrTopic: "ProtocolFeeRecipientUpdate"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "RouterStatusUpdate"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "TokenDeposit"): EventFragment;
}

export type BondingCurveStatusUpdateEvent = TypedEvent<
  [string, boolean] & { bondingCurve: string; isAllowed: boolean }
>;

export type CallTargetStatusUpdateEvent = TypedEvent<
  [string, boolean] & { target: string; isAllowed: boolean }
>;

export type NFTDepositEvent = TypedEvent<[string] & { poolAddress: string }>;

export type NewPairEvent = TypedEvent<[string] & { poolAddress: string }>;

export type OwnershipTransferredEvent = TypedEvent<
  [string, string] & { previousOwner: string; newOwner: string }
>;

export type PriceOracleRegistryUpdateEvent = TypedEvent<
  [string] & { poolAddress: string }
>;

export type ProtocolFeeMultiplierUpdateEvent = TypedEvent<
  [BigNumber] & { newMultiplier: BigNumber }
>;

export type ProtocolFeeRecipientUpdateEvent = TypedEvent<
  [string] & { recipientAddress: string }
>;

export type RouterStatusUpdateEvent = TypedEvent<
  [string, boolean] & { router: string; isAllowed: boolean }
>;

export type TokenDepositEvent = TypedEvent<[string] & { poolAddress: string }>;

export class SeacowsPairFactory extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  listeners<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter?: TypedEventFilter<EventArgsArray, EventArgsObject>
  ): Array<TypedListener<EventArgsArray, EventArgsObject>>;
  off<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>,
    listener: TypedListener<EventArgsArray, EventArgsObject>
  ): this;
  on<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>,
    listener: TypedListener<EventArgsArray, EventArgsObject>
  ): this;
  once<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>,
    listener: TypedListener<EventArgsArray, EventArgsObject>
  ): this;
  removeListener<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>,
    listener: TypedListener<EventArgsArray, EventArgsObject>
  ): this;
  removeAllListeners<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>
  ): this;

  listeners(eventName?: string): Array<Listener>;
  off(eventName: string, listener: Listener): this;
  on(eventName: string, listener: Listener): this;
  once(eventName: string, listener: Listener): this;
  removeListener(eventName: string, listener: Listener): this;
  removeAllListeners(eventName?: string): this;

  queryFilter<EventArgsArray extends Array<any>, EventArgsObject>(
    event: TypedEventFilter<EventArgsArray, EventArgsObject>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEvent<EventArgsArray & EventArgsObject>>>;

  interface: SeacowsPairFactoryInterface;

  functions: {
    addLiquidityERC20(
      _pair: string,
      _nftIDs: BigNumberish[],
      _amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    addLiquidityETH(
      _pair: string,
      _nftIDs: BigNumberish[],
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    bondingCurveAllowed(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    callAllowed(arg0: string, overrides?: CallOverrides): Promise<[boolean]>;

    chainlinkAggregator(overrides?: CallOverrides): Promise<[string]>;

    changePriceOracleRegistry(
      _priceOracleRegistry: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    changeProtocolFeeMultiplier(
      _protocolFeeMultiplier: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    changeProtocolFeeRecipient(
      _protocolFeeRecipient: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    createPairERC20(
      params: {
        token: string;
        nft: string;
        bondingCurve: string;
        assetRecipient: string;
        poolType: BigNumberish;
        delta: BigNumberish;
        fee: BigNumberish;
        spotPrice: BigNumberish;
        initialNFTIDs: BigNumberish[];
        initialTokenBalance: BigNumberish;
      },
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    createPairERC20WithPriceOracle(
      params: {
        token: string;
        nft: string;
        bondingCurve: string;
        assetRecipient: string;
        poolType: BigNumberish;
        delta: BigNumberish;
        fee: BigNumberish;
        initialNFTIDs: BigNumberish[];
        initialTokenBalance: BigNumberish;
      },
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    createPairETH(
      _nft: string,
      _bondingCurve: string,
      _assetRecipient: string,
      _poolType: BigNumberish,
      _delta: BigNumberish,
      _fee: BigNumberish,
      _spotPrice: BigNumberish,
      _initialNFTIDs: BigNumberish[],
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    createPairETHWithPriceOracle(
      _nft: string,
      _bondingCurve: string,
      _assetRecipient: string,
      _poolType: BigNumberish,
      _delta: BigNumberish,
      _fee: BigNumberish,
      _initialNFTIDs: BigNumberish[],
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    depositERC20(
      token: string,
      recipient: string,
      amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    depositNFTs(
      _nft: string,
      ids: BigNumberish[],
      recipient: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    enumerableERC20Template(overrides?: CallOverrides): Promise<[string]>;

    enumerableETHTemplate(overrides?: CallOverrides): Promise<[string]>;

    initializePairERC20FromOracle(
      pair: string,
      _token: string,
      _nft: string,
      _assetRecipient: string,
      _delta: BigNumberish,
      _fee: BigNumberish,
      _spotPrice: BigNumberish,
      _initialNFTIDs: BigNumberish[],
      _initialTokenBalance: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    initializePairETHFromOracle(
      pair: string,
      _nft: string,
      _assetRecipient: string,
      _delta: BigNumberish,
      _fee: BigNumberish,
      _spotPrice: BigNumberish,
      _initialNFTIDs: BigNumberish[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    isPair(
      potentialPair: string,
      variant: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    missingEnumerableERC20Template(
      overrides?: CallOverrides
    ): Promise<[string]>;

    missingEnumerableETHTemplate(overrides?: CallOverrides): Promise<[string]>;

    owner(overrides?: CallOverrides): Promise<[string]>;

    priceOracleRegistry(overrides?: CallOverrides): Promise<[string]>;

    protocolFeeMultiplier(overrides?: CallOverrides): Promise<[BigNumber]>;

    protocolFeeRecipient(overrides?: CallOverrides): Promise<[string]>;

    removeLiquidityERC20(
      _pair: string,
      _amount: BigNumberish,
      _nftIDs: BigNumberish[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    removeLiquidityETH(
      _pair: string,
      _amount: BigNumberish,
      _nftIDs: BigNumberish[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    renounceOwnership(
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    routerStatus(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<
      [boolean, boolean] & { allowed: boolean; wasEverAllowed: boolean }
    >;

    setBondingCurveAllowed(
      bondingCurve: string,
      isAllowed: boolean,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    setCallAllowed(
      target: string,
      isAllowed: boolean,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    setRouterAllowed(
      _router: string,
      isAllowed: boolean,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    transferOwnership(
      newOwner: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    uniswapPriceOracle(overrides?: CallOverrides): Promise<[string]>;

    withdrawERC20ProtocolFees(
      token: string,
      amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    withdrawETHProtocolFees(
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;
  };

  addLiquidityERC20(
    _pair: string,
    _nftIDs: BigNumberish[],
    _amount: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  addLiquidityETH(
    _pair: string,
    _nftIDs: BigNumberish[],
    overrides?: PayableOverrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  bondingCurveAllowed(
    arg0: string,
    overrides?: CallOverrides
  ): Promise<boolean>;

  callAllowed(arg0: string, overrides?: CallOverrides): Promise<boolean>;

  chainlinkAggregator(overrides?: CallOverrides): Promise<string>;

  changePriceOracleRegistry(
    _priceOracleRegistry: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  changeProtocolFeeMultiplier(
    _protocolFeeMultiplier: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  changeProtocolFeeRecipient(
    _protocolFeeRecipient: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  createPairERC20(
    params: {
      token: string;
      nft: string;
      bondingCurve: string;
      assetRecipient: string;
      poolType: BigNumberish;
      delta: BigNumberish;
      fee: BigNumberish;
      spotPrice: BigNumberish;
      initialNFTIDs: BigNumberish[];
      initialTokenBalance: BigNumberish;
    },
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  createPairERC20WithPriceOracle(
    params: {
      token: string;
      nft: string;
      bondingCurve: string;
      assetRecipient: string;
      poolType: BigNumberish;
      delta: BigNumberish;
      fee: BigNumberish;
      initialNFTIDs: BigNumberish[];
      initialTokenBalance: BigNumberish;
    },
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  createPairETH(
    _nft: string,
    _bondingCurve: string,
    _assetRecipient: string,
    _poolType: BigNumberish,
    _delta: BigNumberish,
    _fee: BigNumberish,
    _spotPrice: BigNumberish,
    _initialNFTIDs: BigNumberish[],
    overrides?: PayableOverrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  createPairETHWithPriceOracle(
    _nft: string,
    _bondingCurve: string,
    _assetRecipient: string,
    _poolType: BigNumberish,
    _delta: BigNumberish,
    _fee: BigNumberish,
    _initialNFTIDs: BigNumberish[],
    overrides?: PayableOverrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  depositERC20(
    token: string,
    recipient: string,
    amount: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  depositNFTs(
    _nft: string,
    ids: BigNumberish[],
    recipient: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  enumerableERC20Template(overrides?: CallOverrides): Promise<string>;

  enumerableETHTemplate(overrides?: CallOverrides): Promise<string>;

  initializePairERC20FromOracle(
    pair: string,
    _token: string,
    _nft: string,
    _assetRecipient: string,
    _delta: BigNumberish,
    _fee: BigNumberish,
    _spotPrice: BigNumberish,
    _initialNFTIDs: BigNumberish[],
    _initialTokenBalance: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  initializePairETHFromOracle(
    pair: string,
    _nft: string,
    _assetRecipient: string,
    _delta: BigNumberish,
    _fee: BigNumberish,
    _spotPrice: BigNumberish,
    _initialNFTIDs: BigNumberish[],
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  isPair(
    potentialPair: string,
    variant: BigNumberish,
    overrides?: CallOverrides
  ): Promise<boolean>;

  missingEnumerableERC20Template(overrides?: CallOverrides): Promise<string>;

  missingEnumerableETHTemplate(overrides?: CallOverrides): Promise<string>;

  owner(overrides?: CallOverrides): Promise<string>;

  priceOracleRegistry(overrides?: CallOverrides): Promise<string>;

  protocolFeeMultiplier(overrides?: CallOverrides): Promise<BigNumber>;

  protocolFeeRecipient(overrides?: CallOverrides): Promise<string>;

  removeLiquidityERC20(
    _pair: string,
    _amount: BigNumberish,
    _nftIDs: BigNumberish[],
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  removeLiquidityETH(
    _pair: string,
    _amount: BigNumberish,
    _nftIDs: BigNumberish[],
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  renounceOwnership(
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  routerStatus(
    arg0: string,
    overrides?: CallOverrides
  ): Promise<
    [boolean, boolean] & { allowed: boolean; wasEverAllowed: boolean }
  >;

  setBondingCurveAllowed(
    bondingCurve: string,
    isAllowed: boolean,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  setCallAllowed(
    target: string,
    isAllowed: boolean,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  setRouterAllowed(
    _router: string,
    isAllowed: boolean,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  transferOwnership(
    newOwner: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  uniswapPriceOracle(overrides?: CallOverrides): Promise<string>;

  withdrawERC20ProtocolFees(
    token: string,
    amount: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  withdrawETHProtocolFees(
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  callStatic: {
    addLiquidityERC20(
      _pair: string,
      _nftIDs: BigNumberish[],
      _amount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    addLiquidityETH(
      _pair: string,
      _nftIDs: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<void>;

    bondingCurveAllowed(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<boolean>;

    callAllowed(arg0: string, overrides?: CallOverrides): Promise<boolean>;

    chainlinkAggregator(overrides?: CallOverrides): Promise<string>;

    changePriceOracleRegistry(
      _priceOracleRegistry: string,
      overrides?: CallOverrides
    ): Promise<void>;

    changeProtocolFeeMultiplier(
      _protocolFeeMultiplier: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    changeProtocolFeeRecipient(
      _protocolFeeRecipient: string,
      overrides?: CallOverrides
    ): Promise<void>;

    createPairERC20(
      params: {
        token: string;
        nft: string;
        bondingCurve: string;
        assetRecipient: string;
        poolType: BigNumberish;
        delta: BigNumberish;
        fee: BigNumberish;
        spotPrice: BigNumberish;
        initialNFTIDs: BigNumberish[];
        initialTokenBalance: BigNumberish;
      },
      overrides?: CallOverrides
    ): Promise<string>;

    createPairERC20WithPriceOracle(
      params: {
        token: string;
        nft: string;
        bondingCurve: string;
        assetRecipient: string;
        poolType: BigNumberish;
        delta: BigNumberish;
        fee: BigNumberish;
        initialNFTIDs: BigNumberish[];
        initialTokenBalance: BigNumberish;
      },
      overrides?: CallOverrides
    ): Promise<string>;

    createPairETH(
      _nft: string,
      _bondingCurve: string,
      _assetRecipient: string,
      _poolType: BigNumberish,
      _delta: BigNumberish,
      _fee: BigNumberish,
      _spotPrice: BigNumberish,
      _initialNFTIDs: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<string>;

    createPairETHWithPriceOracle(
      _nft: string,
      _bondingCurve: string,
      _assetRecipient: string,
      _poolType: BigNumberish,
      _delta: BigNumberish,
      _fee: BigNumberish,
      _initialNFTIDs: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<string>;

    depositERC20(
      token: string,
      recipient: string,
      amount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    depositNFTs(
      _nft: string,
      ids: BigNumberish[],
      recipient: string,
      overrides?: CallOverrides
    ): Promise<void>;

    enumerableERC20Template(overrides?: CallOverrides): Promise<string>;

    enumerableETHTemplate(overrides?: CallOverrides): Promise<string>;

    initializePairERC20FromOracle(
      pair: string,
      _token: string,
      _nft: string,
      _assetRecipient: string,
      _delta: BigNumberish,
      _fee: BigNumberish,
      _spotPrice: BigNumberish,
      _initialNFTIDs: BigNumberish[],
      _initialTokenBalance: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    initializePairETHFromOracle(
      pair: string,
      _nft: string,
      _assetRecipient: string,
      _delta: BigNumberish,
      _fee: BigNumberish,
      _spotPrice: BigNumberish,
      _initialNFTIDs: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<void>;

    isPair(
      potentialPair: string,
      variant: BigNumberish,
      overrides?: CallOverrides
    ): Promise<boolean>;

    missingEnumerableERC20Template(overrides?: CallOverrides): Promise<string>;

    missingEnumerableETHTemplate(overrides?: CallOverrides): Promise<string>;

    owner(overrides?: CallOverrides): Promise<string>;

    priceOracleRegistry(overrides?: CallOverrides): Promise<string>;

    protocolFeeMultiplier(overrides?: CallOverrides): Promise<BigNumber>;

    protocolFeeRecipient(overrides?: CallOverrides): Promise<string>;

    removeLiquidityERC20(
      _pair: string,
      _amount: BigNumberish,
      _nftIDs: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<void>;

    removeLiquidityETH(
      _pair: string,
      _amount: BigNumberish,
      _nftIDs: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<void>;

    renounceOwnership(overrides?: CallOverrides): Promise<void>;

    routerStatus(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<
      [boolean, boolean] & { allowed: boolean; wasEverAllowed: boolean }
    >;

    setBondingCurveAllowed(
      bondingCurve: string,
      isAllowed: boolean,
      overrides?: CallOverrides
    ): Promise<void>;

    setCallAllowed(
      target: string,
      isAllowed: boolean,
      overrides?: CallOverrides
    ): Promise<void>;

    setRouterAllowed(
      _router: string,
      isAllowed: boolean,
      overrides?: CallOverrides
    ): Promise<void>;

    transferOwnership(
      newOwner: string,
      overrides?: CallOverrides
    ): Promise<void>;

    uniswapPriceOracle(overrides?: CallOverrides): Promise<string>;

    withdrawERC20ProtocolFees(
      token: string,
      amount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    withdrawETHProtocolFees(overrides?: CallOverrides): Promise<void>;
  };

  filters: {
    "BondingCurveStatusUpdate(address,bool)"(
      bondingCurve?: null,
      isAllowed?: null
    ): TypedEventFilter<
      [string, boolean],
      { bondingCurve: string; isAllowed: boolean }
    >;

    BondingCurveStatusUpdate(
      bondingCurve?: null,
      isAllowed?: null
    ): TypedEventFilter<
      [string, boolean],
      { bondingCurve: string; isAllowed: boolean }
    >;

    "CallTargetStatusUpdate(address,bool)"(
      target?: null,
      isAllowed?: null
    ): TypedEventFilter<
      [string, boolean],
      { target: string; isAllowed: boolean }
    >;

    CallTargetStatusUpdate(
      target?: null,
      isAllowed?: null
    ): TypedEventFilter<
      [string, boolean],
      { target: string; isAllowed: boolean }
    >;

    "NFTDeposit(address)"(
      poolAddress?: null
    ): TypedEventFilter<[string], { poolAddress: string }>;

    NFTDeposit(
      poolAddress?: null
    ): TypedEventFilter<[string], { poolAddress: string }>;

    "NewPair(address)"(
      poolAddress?: null
    ): TypedEventFilter<[string], { poolAddress: string }>;

    NewPair(
      poolAddress?: null
    ): TypedEventFilter<[string], { poolAddress: string }>;

    "OwnershipTransferred(address,address)"(
      previousOwner?: string | null,
      newOwner?: string | null
    ): TypedEventFilter<
      [string, string],
      { previousOwner: string; newOwner: string }
    >;

    OwnershipTransferred(
      previousOwner?: string | null,
      newOwner?: string | null
    ): TypedEventFilter<
      [string, string],
      { previousOwner: string; newOwner: string }
    >;

    "PriceOracleRegistryUpdate(address)"(
      poolAddress?: null
    ): TypedEventFilter<[string], { poolAddress: string }>;

    PriceOracleRegistryUpdate(
      poolAddress?: null
    ): TypedEventFilter<[string], { poolAddress: string }>;

    "ProtocolFeeMultiplierUpdate(uint256)"(
      newMultiplier?: null
    ): TypedEventFilter<[BigNumber], { newMultiplier: BigNumber }>;

    ProtocolFeeMultiplierUpdate(
      newMultiplier?: null
    ): TypedEventFilter<[BigNumber], { newMultiplier: BigNumber }>;

    "ProtocolFeeRecipientUpdate(address)"(
      recipientAddress?: null
    ): TypedEventFilter<[string], { recipientAddress: string }>;

    ProtocolFeeRecipientUpdate(
      recipientAddress?: null
    ): TypedEventFilter<[string], { recipientAddress: string }>;

    "RouterStatusUpdate(address,bool)"(
      router?: null,
      isAllowed?: null
    ): TypedEventFilter<
      [string, boolean],
      { router: string; isAllowed: boolean }
    >;

    RouterStatusUpdate(
      router?: null,
      isAllowed?: null
    ): TypedEventFilter<
      [string, boolean],
      { router: string; isAllowed: boolean }
    >;

    "TokenDeposit(address)"(
      poolAddress?: null
    ): TypedEventFilter<[string], { poolAddress: string }>;

    TokenDeposit(
      poolAddress?: null
    ): TypedEventFilter<[string], { poolAddress: string }>;
  };

  estimateGas: {
    addLiquidityERC20(
      _pair: string,
      _nftIDs: BigNumberish[],
      _amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    addLiquidityETH(
      _pair: string,
      _nftIDs: BigNumberish[],
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    bondingCurveAllowed(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    callAllowed(arg0: string, overrides?: CallOverrides): Promise<BigNumber>;

    chainlinkAggregator(overrides?: CallOverrides): Promise<BigNumber>;

    changePriceOracleRegistry(
      _priceOracleRegistry: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    changeProtocolFeeMultiplier(
      _protocolFeeMultiplier: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    changeProtocolFeeRecipient(
      _protocolFeeRecipient: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    createPairERC20(
      params: {
        token: string;
        nft: string;
        bondingCurve: string;
        assetRecipient: string;
        poolType: BigNumberish;
        delta: BigNumberish;
        fee: BigNumberish;
        spotPrice: BigNumberish;
        initialNFTIDs: BigNumberish[];
        initialTokenBalance: BigNumberish;
      },
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    createPairERC20WithPriceOracle(
      params: {
        token: string;
        nft: string;
        bondingCurve: string;
        assetRecipient: string;
        poolType: BigNumberish;
        delta: BigNumberish;
        fee: BigNumberish;
        initialNFTIDs: BigNumberish[];
        initialTokenBalance: BigNumberish;
      },
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    createPairETH(
      _nft: string,
      _bondingCurve: string,
      _assetRecipient: string,
      _poolType: BigNumberish,
      _delta: BigNumberish,
      _fee: BigNumberish,
      _spotPrice: BigNumberish,
      _initialNFTIDs: BigNumberish[],
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    createPairETHWithPriceOracle(
      _nft: string,
      _bondingCurve: string,
      _assetRecipient: string,
      _poolType: BigNumberish,
      _delta: BigNumberish,
      _fee: BigNumberish,
      _initialNFTIDs: BigNumberish[],
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    depositERC20(
      token: string,
      recipient: string,
      amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    depositNFTs(
      _nft: string,
      ids: BigNumberish[],
      recipient: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    enumerableERC20Template(overrides?: CallOverrides): Promise<BigNumber>;

    enumerableETHTemplate(overrides?: CallOverrides): Promise<BigNumber>;

    initializePairERC20FromOracle(
      pair: string,
      _token: string,
      _nft: string,
      _assetRecipient: string,
      _delta: BigNumberish,
      _fee: BigNumberish,
      _spotPrice: BigNumberish,
      _initialNFTIDs: BigNumberish[],
      _initialTokenBalance: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    initializePairETHFromOracle(
      pair: string,
      _nft: string,
      _assetRecipient: string,
      _delta: BigNumberish,
      _fee: BigNumberish,
      _spotPrice: BigNumberish,
      _initialNFTIDs: BigNumberish[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    isPair(
      potentialPair: string,
      variant: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    missingEnumerableERC20Template(
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    missingEnumerableETHTemplate(overrides?: CallOverrides): Promise<BigNumber>;

    owner(overrides?: CallOverrides): Promise<BigNumber>;

    priceOracleRegistry(overrides?: CallOverrides): Promise<BigNumber>;

    protocolFeeMultiplier(overrides?: CallOverrides): Promise<BigNumber>;

    protocolFeeRecipient(overrides?: CallOverrides): Promise<BigNumber>;

    removeLiquidityERC20(
      _pair: string,
      _amount: BigNumberish,
      _nftIDs: BigNumberish[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    removeLiquidityETH(
      _pair: string,
      _amount: BigNumberish,
      _nftIDs: BigNumberish[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    renounceOwnership(
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    routerStatus(arg0: string, overrides?: CallOverrides): Promise<BigNumber>;

    setBondingCurveAllowed(
      bondingCurve: string,
      isAllowed: boolean,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    setCallAllowed(
      target: string,
      isAllowed: boolean,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    setRouterAllowed(
      _router: string,
      isAllowed: boolean,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    transferOwnership(
      newOwner: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    uniswapPriceOracle(overrides?: CallOverrides): Promise<BigNumber>;

    withdrawERC20ProtocolFees(
      token: string,
      amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    withdrawETHProtocolFees(
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    addLiquidityERC20(
      _pair: string,
      _nftIDs: BigNumberish[],
      _amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    addLiquidityETH(
      _pair: string,
      _nftIDs: BigNumberish[],
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    bondingCurveAllowed(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    callAllowed(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    chainlinkAggregator(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    changePriceOracleRegistry(
      _priceOracleRegistry: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    changeProtocolFeeMultiplier(
      _protocolFeeMultiplier: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    changeProtocolFeeRecipient(
      _protocolFeeRecipient: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    createPairERC20(
      params: {
        token: string;
        nft: string;
        bondingCurve: string;
        assetRecipient: string;
        poolType: BigNumberish;
        delta: BigNumberish;
        fee: BigNumberish;
        spotPrice: BigNumberish;
        initialNFTIDs: BigNumberish[];
        initialTokenBalance: BigNumberish;
      },
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    createPairERC20WithPriceOracle(
      params: {
        token: string;
        nft: string;
        bondingCurve: string;
        assetRecipient: string;
        poolType: BigNumberish;
        delta: BigNumberish;
        fee: BigNumberish;
        initialNFTIDs: BigNumberish[];
        initialTokenBalance: BigNumberish;
      },
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    createPairETH(
      _nft: string,
      _bondingCurve: string,
      _assetRecipient: string,
      _poolType: BigNumberish,
      _delta: BigNumberish,
      _fee: BigNumberish,
      _spotPrice: BigNumberish,
      _initialNFTIDs: BigNumberish[],
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    createPairETHWithPriceOracle(
      _nft: string,
      _bondingCurve: string,
      _assetRecipient: string,
      _poolType: BigNumberish,
      _delta: BigNumberish,
      _fee: BigNumberish,
      _initialNFTIDs: BigNumberish[],
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    depositERC20(
      token: string,
      recipient: string,
      amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    depositNFTs(
      _nft: string,
      ids: BigNumberish[],
      recipient: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    enumerableERC20Template(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    enumerableETHTemplate(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    initializePairERC20FromOracle(
      pair: string,
      _token: string,
      _nft: string,
      _assetRecipient: string,
      _delta: BigNumberish,
      _fee: BigNumberish,
      _spotPrice: BigNumberish,
      _initialNFTIDs: BigNumberish[],
      _initialTokenBalance: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    initializePairETHFromOracle(
      pair: string,
      _nft: string,
      _assetRecipient: string,
      _delta: BigNumberish,
      _fee: BigNumberish,
      _spotPrice: BigNumberish,
      _initialNFTIDs: BigNumberish[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    isPair(
      potentialPair: string,
      variant: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    missingEnumerableERC20Template(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    missingEnumerableETHTemplate(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    owner(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    priceOracleRegistry(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    protocolFeeMultiplier(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    protocolFeeRecipient(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    removeLiquidityERC20(
      _pair: string,
      _amount: BigNumberish,
      _nftIDs: BigNumberish[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    removeLiquidityETH(
      _pair: string,
      _amount: BigNumberish,
      _nftIDs: BigNumberish[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    renounceOwnership(
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    routerStatus(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    setBondingCurveAllowed(
      bondingCurve: string,
      isAllowed: boolean,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    setCallAllowed(
      target: string,
      isAllowed: boolean,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    setRouterAllowed(
      _router: string,
      isAllowed: boolean,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    transferOwnership(
      newOwner: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    uniswapPriceOracle(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    withdrawERC20ProtocolFees(
      token: string,
      amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    withdrawETHProtocolFees(
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;
  };
}
